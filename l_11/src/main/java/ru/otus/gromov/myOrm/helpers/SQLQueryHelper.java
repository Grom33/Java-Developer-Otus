package ru.otus.gromov.myOrm.helpers;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import ru.otus.gromov.base.dataSets.DataSet;

import javax.persistence.ManyToOne;
import javax.persistence.OneToMany;
import javax.persistence.OneToOne;
import java.lang.reflect.Field;
import java.lang.reflect.Modifier;
import java.util.*;
import java.util.function.Function;
import java.util.stream.Collectors;

public class SQLQueryHelper {
	private static final String NO_ANNOTATIONS = "NoAnnotations";

	private Map<String, Collection<Field>> objectStucture;
	private final Logger log = LoggerFactory.getLogger(getClass());

	public String buildQuery(Object object) {
		ripObject(object);
		StringBuilder resultQuery = new StringBuilder();

		addQueryToResultQuery(object, resultQuery, function -> {
			SqlObject sqlObject = (SqlObject) function;
			return getInitQuery(sqlObject.getObject(),
					sqlObject.getFields(), sqlObject.getParentId());
		});

		addQueryToResultQuery(object, resultQuery, function -> {
			SqlObject sqlObject = (SqlObject) function;
			return getValueQuery(sqlObject.getObject(),
					sqlObject.getFields(), sqlObject.getParentId());
		});

		return resultQuery.toString();
	}

	private void addQueryToResultQuery(Object object, StringBuilder resultQuery, Function function) {
		objectStucture.forEach((key, value) -> {
			if (key.equals(NO_ANNOTATIONS)) {
				resultQuery.append(function.apply(new SqlObject(object, value, 0)) + "\n");
			} else {
				value.forEach(field -> {
					Object childObject = ReflectionHelper.getFieldValueByField(object, field);
					if (childObject instanceof Collection) {
						((Collection<Object>) childObject).forEach(o -> {
									List<Field> childObjectyFields = ReflectionHelper.getFields(o);
									resultQuery.append(
											function.apply(new SqlObject(o,
													childObjectyFields,
													((DataSet) object).getId()) + "\n"));
								}
						);
					} else {
						List<Field> childObjectyFields = ReflectionHelper.getFields(childObject);
						resultQuery.append(
								function.apply(new SqlObject(
										childObject,
										childObjectyFields,
										((DataSet) object).getId())) + "\n");
					}
				});
			}
		});
	}

	private void ripObject(Object object) {
		objectStucture = new HashMap<>();
		List<Field> fields = ReflectionHelper.getFields(object);
		fields.forEach(field -> {
			String structureKey = NO_ANNOTATIONS;
			if (field.getDeclaredAnnotations() != null) {
				if (field.isAnnotationPresent(OneToOne.class)) {
					structureKey = OneToOne.class.getSimpleName();
				} else if (field.isAnnotationPresent(OneToMany.class)) {
					structureKey = OneToMany.class.getSimpleName();
				}
			}
			appendToObjectStructure(structureKey, field);
		});

	}

	private String getValueQuery(Object object, Collection<Field> fields, long parentId) {
		String parentIdName = "";
		String parentIdValue = "";
		if (parentId > 0) {
			parentIdName = ", parentid bigint";
			parentIdValue = ", " + String.valueOf(parentId);
		}
		return String.format("INSERT INTO %s (%s) VALUES (%s);",
				object.getClass().getSimpleName(),
				fields.stream()
						.filter(this::isSkipedField)
						.map(Field::getName)
						.collect(Collectors.joining(", ")) + parentIdName,
				fields.stream()
						.filter(this::isSkipedField)
						.map(field -> wrapString(ReflectionHelper.getFieldValueByField(object, field)))
						.collect(Collectors.joining(", ")) + parentIdValue
		);
	}

	private String getInitQuery(Object object, Collection<Field> fields, long parentId) {

		StringBuilder initQuery = new StringBuilder();
		initQuery.append(String.format("CREATE TABLE IF NOT EXISTS %s (", object.getClass().getSimpleName()));
		initQuery.append("id bigint generated by default as identity, ");
		fields.forEach((f) -> {
			if (!"id".equals(f.getName()) & (isSkipedField(f))) {
				initQuery.append(String.format(" %s %s,", f.getName(), getSqlType(f.getType())));
			}
		});
		if (parentId > 0) initQuery.append(" parentid bigint, ");
		initQuery.append(" primary key (id));");
		return initQuery.toString();
	}

	private void appendToObjectStructure(String structureKey, Field field) {
		if (!objectStucture.containsKey(structureKey)) objectStucture.put(structureKey, new ArrayList<>());
		objectStucture.get(structureKey).add(field);

	}

	private boolean isSkipedField(Field field) {
		boolean result = true;
		if (Modifier.isTransient(field.getModifiers())) return false;
		if (field.getDeclaredAnnotations() != null) {
			if (field.isAnnotationPresent(OneToOne.class)) {
				return false;
			} else if (field.isAnnotationPresent(OneToMany.class)) {
				return false;
			} else if (field.isAnnotationPresent(ManyToOne.class)) {
				return false;
			}
		}
		return result;
	}

	private String getSqlType(Class clazz) {
		if (int.class.isAssignableFrom(clazz)) return "int";
		if (long.class.isAssignableFrom(clazz)) return "bigint";
		if (float.class.isAssignableFrom(clazz)) return "float";
		if (double.class.isAssignableFrom(clazz)) return "float";
		if (String.class.isAssignableFrom(clazz)) return "varchar(255)";
		if (boolean.class.isAssignableFrom(clazz)) return "boolean";
		return "varchar(255)";
	}

	private String wrapString(Object object) {
		if (object instanceof String) return String.format("'%s'", object);
		return object.toString();
	}

	public class SqlObject {
		private Object object;
		private Collection<Field> fields;
		private long parentId;

		SqlObject(Object object, Collection<Field> fields, long parentId) {
			this.object = object;
			this.fields = fields;
			this.parentId = parentId;
		}

		public Object getObject() {
			return object;
		}

		Collection<Field> getFields() {
			return fields;
		}


		long getParentId() {
			return parentId;
		}

	}
}

